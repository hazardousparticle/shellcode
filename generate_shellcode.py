#!/bin/env python3

import re
import sys
import os

# round a number to nearest multiple of 8
#def roundup(x, nearest = 4):
#    return x if x % nearest == 0 else x + nearest - x % nearest

def generate_escaped_string(shell_code,convert_to_octal = False):

    escaped_shell_code = ""
    
    for i in shell_code:
        if not convert_to_octal:
            escaped_shell_code += "\\x"
            escaped_shell_code += i
        else:
            tmp = int(i, 16)
            s = oct(tmp)
            s = s.replace("0o","")
            s = s.zfill(3)
            s = "\\" + s
            escaped_shell_code += s
    
    return escaped_shell_code


if __name__ == "__main__":
    find_hex_digit_regex = "(?<=\s)(([a-f]|[0-9]){2})(?=\ )"
    
    if len(sys.argv) == 1:
        print("Tool for parsing dump of binary and converting to escaped shellcode")
        print("usage: " + str(sys.argv[0]) + " file [--octal]")
        print("")
        print("file - text file generated by objdump or shell script on a binary file")
        print("--octal - convert the output chars to octal instead of hex")
        exit(3)

    file_name = str(sys.argv[1])
    
    convert_to_octal = False
    if len(sys.argv) > 2:
        if str(sys.argv[2]) == "--octal":
            convert_to_octal = True
    
    with open(file_name, "r") as asm_file:
        f = asm_file.read()
        
    matches = re.findall(find_hex_digit_regex, f)
    
    shell_code = []
    
    # once the binary is disassembled, pass the output for hex machine code
    
    for item in matches:
        shell_code.append(item[0])

    size = len(shell_code)

    escaped_shell_code = generate_escaped_string(shell_code, convert_to_octal)
    
    print("Length: " + str(size))
    print("")
    print("Shell code:\n")
    
    print(escaped_shell_code)
    
    print("")
    

